const initModel = {
	nextId: 12,
	cards: [
		{
			id: 11,
			question: 'Wyjaśnij czym jest currying?',
			answer: 'Jest to transformacja z funkcji z wieloma argumentami do funkcji, która bierze pojedyńczy argument i zwraca funkcję z pozostałymi argumentami.',
			rank: 0,
			showAnswer: false,
			edit: false,
		},
		{
			id: 10,
			question: 'Podaj różnice między pojęciami curry, a partial application.',
			answer: 'Curry jest tym, co robię z funkcją, zanim faktycznie zacznę ją wykorzystywać. Powiązane z tworzeniem funkcji - nie ma tu danych. Partial app jest tym, co zostało zrobione, gdy zacznę używać funkcji częściowo. Powiązane z używaniem funkcji z danymi. Dostarcza funkcji mniejszą liczbę argumentów, niż to konieczne. Potem zwracana jest nowa funkcja, która pobiera pozostałe parametry.',
			rank: 0,
			showAnswer: false,
			edit: false,
		},
		{
			id: 9,
			question: 'Podaj różnice między pure function, a impure function (procedure).',
			answer: 'PURE fn: 1. Musi mieć parametr wejściowy. 2. Nie może zależeć od zmiennych poza daną faunkcją, które mogłyby ulec zmianie. 3. zwraca wartość, która jest determinowana tylko przez parametr wejściowy. 4. Nie może powodować skutków uboczynch. IMPURE fn: wystarczy, że nie spełni jednej z zasad. Można powiedzieć, że nie jest to funkcja, a procedura. ',
			rank: 0,
			showAnswer: false,
			edit: false,
		},
		{
			id: 8,
			question: 'Czym jest kompozycja funkcji?',
			answer: 'Polega na tworzeniu nowych funkcji z innych, przez połączenie ze sobą ich logiki. Gdy rezultat jednej funkcji jest tego samego typu, co parametr wejściowy innej funkcji, mogę je połączyć.',
			rank: 0,
			showAnswer: false,
			edit: false,
		},
		{
			id: 7,
			question: 'Co oznacza strict mode?',
			answer: 'Tryb ten umożliwia umieścić program lub funkcję w ścisłym kontekście operacyjnym. W skrócie - ułatwia debugowanie. Błędy w kodzie, które mogłyby być ignorowane, będą w tym trybie generowane. Przykładowe zmiany: 1. Używanie zmiennej, zanim ją zdefiniuję wywoła błąd. 2. Powstrzymuje od używania słów, które są zarezerwowane dla przyszłych wersji JS. 3. Nie można usuwać funkcji, zmiennych, argumnetów.',
			rank: 0,
			showAnswer: false,
			edit: false,
		},
		{
			id: 6,
			question: 'Czy JS przekazuje zmienne przez odniesienie, czy wartość?',
			answer: 'Wartości prymitywe jako wartość, obiekty jako odniesienie. PASS BY VALUE oznacza, że jeśli zmienię prymitywną wartość wew. funkcji, te zmiany NIE wpłyną na zmienną w przestrzeni zewnętrznej. PASS BY REFERENCE - przekazuję coś, co wskazuje na coś innego. Po zmianie właściwości obiektu wew. funkcji, zmienię też właściwość w przestrzeni zewnętrznej.',
			rank: 0,
			showAnswer: false,
			edit: false,
		},
		{
			id: 5,
			question: 'Czym różni się równość od ścisłej równości?',
			answer: 'Ścisła równość sprawdza zarówno typ, jak i wartość. Równość sprawdza wartość między operatorem. W równości JS konwertuje wartości, więc są tego samego typu. Przykład: 0 == \'0\' tutaj JS konweruje liczbę po lewej w string. Nazywa się to \'type coercion\'. Jeśli wartości po obu stronach operatora == są różnego rodzaju, JS próbuje zrobić, by były tego samego typu.',
			rank: 0,
			showAnswer: false,
			edit: false,
		},
		{
			id: 4,
			question: 'Co oznacza JSONP i jak działa?',
			answer: 'To rozwiązanie problemu z same origin policy w przeglądarce. Tego samego, który rozwiązuje CORS, posiada jednak pewne limity - przede wszystkim działa jedynie z żądaniem GET, z drugiej strony, działa dobrze bez dodatkowej konfigiracji. Jest więc to dobra alternatywa. Jak działa: 1. Tworzy losową nazwę funkcji. 2. Upewnia się, że jest dostępna dla przeglądarki. 3. Tworzy skrypt. 4. Dodaje zapytanie do API. 5. Dodaje tag na stronie. 6. Przeglądarka pobiera odpowiedź z API i ją wykonuje.',
			rank: 0,
			showAnswer: false,
			edit: false, 
		},
		{
			id: 3,
			question: 'event capturing vs bubbling',
			answer: 'Niezależnie od tego, gdzie klilknę na stronie, event zawsze wystartuje od root (DOM -> window -> document ... -> target), idzie do target, i wraca do root ponownie. Mam więc dwie ścieżki, jakie pokonuje event, a każdy element na ścieżce eventu, otrzymuje powiadomienie dwa razy. Pierwsza ścieżka, od root do target to faza 1 - event capturing. Druga ścieżka, od target do root to faza 2 - event bubbling. Gdy dodaję zdarzenie, można wybrać, którą fazę wybieram. Jeśli tego nie określę, domyślnie zostaje przydzielona faza bubbling.',
			rank: 0,
			showAnswer: false,
			edit: false, 
		},
		{
			id: 2,
			question: 'stopPropagation() vs preventDefault()',
			answer: 'stopPropagation całkowicie zatrzymuje event przed przejściem dalej, natomiast preventDefault nie zatrzymuje event przed rozprzestrzenianiem się po kolejnych elementach DOM, a zatrzymuje domyślne zachowanie, które event mógłby wykonać na danym elementcie (np. zaznaczenie pola)',
			rank: 0,
			showAnswer: false,
			edit: false, 
		},
		{
			id: 1,
			question: 'Wymień i wyjaśnij podstawowe założenia OOP',
			answer: 'Enkapsulacja - polega na grupowaniu powiązanych zmiennych i funkcji w obiekty. Abstrakcja - polega na ukryciu pewnych właściwości i metod przed zewnętrzną przestrzenią, pokazuje tylko niezbędne rzeczy. Sprawia, że interfejs obiektów bedzie prostszy, pozwala ograniczyć wpływ zmian. Jeśli zmienię wewmętrzne metody, żadna z tych metod nie wycieknie na zewnątrz. Dziedziczenie - pozwala wyeliminować zbędny kod, np. przez zdefiniowanie jednej metody w obiekcie, którą dziedziczą inne. Polimorfizm - czyli wiele form. W OOP to technika, która pozwala pozbyć się długich instrukcji typu if/else, switch itd.',
			rank: 0,
			showAnswer: false,
			edit: false, 
		},
		{
			id: 0,
			question: 'Czym jest hoisting, kiedy powstaje?',
			answer: 'W JS funkcje i zmienne są hoistowane, co oznacza, że są dostępne zanim faza wykonania się rozpocznie. Funkcje są już określone, zdefiniowane zanim zacznie się faza wykonania, natomiast zmienne są ustawiane \'jako undefined\', będą zdefiniowane w fazie wykonania. Co więcej, hoisting działa tylko w przypadku deklaracji funkcji, nie przy wyrażeniu funkcji. W przypadku klas - zarówno deklaracje jak i wyrażenia nie są hoistowane. KIEDY POWSTAJE: w pierwszej fazie (creation phase), przy tworzeniu zmiennej obiektu, zmienna obiektu tworzona jest przy powstawaniu kontekstu wykonawczego.',
			rank: 0,
			showAnswer: false,
			edit: false, 
		},
	],
};

export default initModel;
